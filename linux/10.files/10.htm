<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0063)http://man.chinaunix.net/develop/c&c++/linux_c/function/10.html -->
<HTML><HEAD><TITLE>Untitled Document</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8">
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY><A target = "_top" href="../../">&lt;&lt; 返回博客首页 
</A><BR><BR>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc147></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>clearerr（清除文件流的错误旗标） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>feof<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>void clearerr(FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
  size=2>clearerr（）清除参数stream指定的文件流所使用的错误旗标。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80 height=39>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc148></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fclose（关闭文件） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>close，fflush，fopen，setbuf<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int fclose(FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>fclose()用来关闭先前fopen()打开的文件。此动作会让缓冲区内的数据写入文件中，并释放系统所提供的文件资源。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 
    size=2>若关文件动作成功则返回0，有错误发生时则返回EOF并把错误代码存到errno。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>错误代码 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>EBADF表示参数stream非已打开的文件。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>请参考fopen（）。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc149></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fdopen（将文件描述词转为文件指针） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fopen，open，fclose<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>FILE * fdopen(int fildes,const char * 
      mode);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fdopen()会将参数fildes 的文件描述词，转换为对应的文件指针后返回。参数mode 
      字符串则代表着文件指针的流形态，此形态必须和原先文件描述词读写模式相同。关于mode 
  字符串格式请参考fopen()。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>转换成功时返回指向该流的文件指针。失败则返回NULL，并把错误代码存在errno中。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR>main()<BR>{<BR>FILE * 
      fp 
      =fdopen(0,”w+”);<BR>fprintf(fp,”%s\n”,”hello!”);<BR>fclose(fp);<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>执行 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>hello!<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc150></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>feof（检查文件流是否读到了文件尾） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fopen，fgetc，fgets，fread<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int feof(FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>feof()用来侦测是否读取到了文件尾，尾数stream为fopen（）所返回之文件指针。如果已到文件尾则返回非零值，其他情况返回0。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>返回非零值代表已到达文件尾。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc151></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fflush（更新缓冲区） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>write，fopen，fclose，setbuf<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int fflush(FILE* stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>fflush()会强迫将缓冲区内的数据写回参数stream指定的文件中。如果参数stream为NULL，fflush()会将所有打开的文件数据更新。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>成功返回0，失败返回EOF，错误代码存于errno中。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>错误代码 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>EBADF 参数stream 
      指定的文件未被打开，或打开状态为只读。其它错误代码参考write（）。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc152></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fgetc（由文件中读取一个字符） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>open，fread，fscanf，getc<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>nt fgetc(FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>fgetc()从参数stream所指的文件中读取一个字符。若读到文件尾而无数据时便返回EOF。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>getc()会返回读取到的字符，若返回EOF则表示到了文件尾。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR>main()<BR>{<BR>FILE 
      *fp;<BR>int 
      c;<BR>fp=fopen(“exist”,”r”);<BR>while((c=fgetc(fp))!=EOF)<BR>printf(“%c”,c);<BR>fclose(fp);<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc153></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fgets（由文件中读取一字符串） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>open，fread，fscanf，getc<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>har * fgets(char * s,int size,FILE * 
      stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>fgets()用来从参数stream所指的文件内读入字符并存到参数s所指的内存空间，直到出现换行字符、读到文件尾或是已读了size-1个字符为止，最后会加上NULL作为字符串结束。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>gets()若成功则返回s指针，返回NULL则表示有错误发生。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR>main()<BR>{<BR>char 
      s[80];<BR>fputs(fgets(s,80,stdin),stdout);<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>执行 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>this is a test /*输入*/<BR>this is a test 
      /*输出*/<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc154></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fileno（返回文件流所使用的文件描述词） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>open，fopen<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int fileno(FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
  size=2>fileno()用来取得参数stream指定的文件流所使用的文件描述词。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>返回文件描述词。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR>main()<BR>{<BR>FILE * 
      fp;<BR>int 
      fd;<BR>fp=fopen(“/etc/passwd”,”r”);<BR>fd=fileno(fp);<BR>printf(“fd=%d\n”,fd);<BR>fclose(fp);<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>执行 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fd=3<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc155></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fopen（打开文件） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>open，fclose<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>FILE * fopen(const char * path,const char * 
      mode);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。<BR>mode有下列几种形态字符串:<BR>r 
      打开只读文件，该文件必须存在。<BR>r+ 打开可读写的文件，该文件必须存在。<BR>w 
      打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。<BR>w+ 
      打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。<BR>a 
      以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。<BR>a+ 
      以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。<BR>上述的形态字符串都可以再加一个b字符，如rb、w+b或ab＋等组合，加入b 
      字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。不过在POSIX系统，包含Linux都会忽略该字符。由fopen()所建立的新文件会具有S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)权限，此文件权限也会参考umask值。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>文件顺利打开后，指向该流的文件指针就会被返回。若果文件打开失败则返回NULL，并把错误代码存在errno 
    中。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>附加说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>一般而言，开文件后会作一些文件读取或写入的动作，若开文件失败，接下来的读写动作也无法顺利进行，所以在fopen()后请作错误判断及处理。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR>main()<BR>{<BR>FILE * 
      fp;<BR>fp=fopen(“noexist”,”a+”);<BR>if(fp= =NULL) 
      return;<BR>fclose(fp);<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc156></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fputc（将一指定字符写入文件流中） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fopen，fwrite，fscanf，putc<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int fputc(int c,FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fputc 会将参数c 转为unsigned char 后写入参数stream 
      指定的文件中。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 
    size=2>fputc()会返回写入成功的字符，即参数c。若返回EOF则代表写入失败。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR>main()<BR>{<BR>FILE * 
      fp;<BR>char a[26]=”abcdefghijklmnopqrstuvwxyz”;<BR>int i;<BR>fp= 
      fopen(“noexist”,”w”);<BR>for(i=0;i&lt;26;i++)<BR>fputc(a[i],fp);<BR>fclose(fp);<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc157></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fputs（将一指定的字符串写入文件内） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fopen，fwrite，fscanf，fputc，putc<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int fputs(const char * s,FILE * 
      stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
    size=2>fputs()用来将参数s所指的字符串写入到参数stream所指的文件内。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>若成功则返回写出的字符个数，返回EOF则表示有错误发生。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>请参考fgets（）。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc158></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fread（从文件流读取数据） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fopen，fwrite，fseek，fscanf<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>size_t fread(void * ptr,size_t size,size_t 
      nmemb,FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fread()用来从文件流中读取数据。参数stream为已打开的文件指针，参数ptr 
      指向欲存放读取进来的数据空间，读取的字符数以参数size*nmemb来决定。Fread()会返回实际读取到的nmemb数目，如果此值比参数nmemb 
      来得小，则代表可能读到了文件尾或有错误发生，这时必须用feof()或ferror()来决定发生什么情况。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>返回实际读取到的nmemb数目。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>附加说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR>#define nmemb 
      3<BR>struct test<BR>{<BR>char name[20];<BR>int 
      size;<BR>}s[nmemb];<BR>main()<BR>{<BR>FILE * stream;<BR>int i;<BR>stream = 
      fopen(“/tmp/fwrite”,”r”);<BR>fread(s,sizeof(struct 
      test),nmemb,stream);<BR>fclose(stream);<BR>for(i=0;i&lt;nmemb;i++)<BR>printf(“name[%d]=%-20s:size[%d]=%d\n”,i,s[i].name,i,s[i].size);<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>执行 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>name[0]=Linux! size[0]=6<BR>name[1]=FreeBSD! 
      size[1]=8<BR>name[2]=Windows2000 size[2]=11<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc159></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>freopen（打开文件） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fopen，fclose<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>FILE * freopen(const char * path,const char * 
      mode,FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>参数path字符串包含欲打开的文件路径及文件名，参数mode请参考fopen()说明。参数stream为已打开的文件指针。Freopen()会将原stream所打开的文件流关闭，然后打开参数path的文件。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno 
    中。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR>main()<BR>{<BR>FILE * 
      fp;<BR>fp=fopen(“/etc/passwd”,”r”);<BR>fp=freopen(“/etc/group”,”r”,fp);<BR>fclose(fp);<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc160></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fseek（移动文件流的读写位置） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 
  size=2>rewind，ftell，fgetpos，fsetpos，lseek<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int fseek(FILE * stream,long offset,int 
      whence);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>fseek()用来移动文件流的读写位置。参数stream为已打开的文件指针，参数offset为根据参数whence来移动读写位置的位移数。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>参数 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>whence为下列其中一种:<BR>SEEK_SET从距文件开头offset位移量为新的读写位置。SEEK_CUR 
      以目前的读写位置往后增加offset个位移量。<BR>SEEK_END将读写位置指向文件尾后再增加offset个位移量。<BR>当whence值为SEEK_CUR 
      或SEEK_END时，参数offset允许负值的出现。<BR>下列是较特别的使用方式:<BR>1) 
      欲将读写位置移动到文件开头时:fseek(FILE *stream,0,SEEK_SET);<BR>2) 
      欲将读写位置移动到文件尾时:fseek(FILE *stream,0,0SEEK_END);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 
  size=2>当调用成功时则返回0，若有错误则返回-1，errno会存放错误代码。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>附加说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>fseek()不像lseek()会返回读写位置，因此必须使用ftell()来取得目前读写的位置。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR>main()<BR>{<BR>FILE * 
      stream;<BR>long offset;<BR>fpos_t 
      pos;<BR>stream=fopen(“/etc/passwd”,”r”);<BR>fseek(stream,5,SEEK_SET);<BR>printf(“offset=%d\n”,ftell(stream));<BR>rewind(stream);<BR>fgetpos(stream,&amp;pos);<BR>printf(“offset=%d\n”,pos);<BR>pos=10;<BR>fsetpos(stream,&amp;pos);<BR>printf(“offset 
      = %d\n”,ftell(stream));<BR>fclose(stream);<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>执行 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>offset = 5<BR>offset 
  =0<BR>offset=10<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc161></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>ftell（取得文件流的读取位置） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fseek，rewind，fgetpos，fsetpos<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>long ftell(FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>ftell()用来取得文件流目前的读写位置。参数stream为已打开的文件指针。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>当调用成功时则返回目前的读写位置，若有错误则返回-1，errno会存放错误代码。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>错误代码 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>EBADF 参数stream无效或可移动读写位置的文件流。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>参考fseek()。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc162></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>fwrite（将数据写至文件流） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fopen，fread，fseek，fscanf<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>size_t fwrite(const void * ptr,size_t size,size_t 
      nmemb,FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fwrite()用来将数据写入文件流中。参数stream为已打开的文件指针，参数ptr 
      指向欲写入的数据地址，总共写入的字符数以参数size*nmemb来决定。Fwrite()会返回实际写入的nmemb数目。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>返回实际写入的nmemb数目。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR>#define set_s (x,y) 
      {strcoy(s[x].name,y);s[x].size=strlen(y);}<BR>#define nmemb 3<BR>struct 
      test<BR>{<BR>char name[20];<BR>int 
      size;<BR>}s[nmemb];<BR>main()<BR>{<BR>FILE * 
      stream;<BR>set_s(0,”Linux!”);<BR>set_s(1,”FreeBSD!”);<BR>set_s(2,”Windows2000.”);<BR>stream=fopen(“/tmp/fwrite”,”w”);<BR>fwrite(s,sizeof(struct 
      test),nmemb,stream);<BR>fclose(stream);<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>执行 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>参考fread（）。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc163></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>getc（由文件中读取一个字符） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>read，fopen，fread，fgetc<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int getc(FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>getc()用来从参数stream所指的文件中读取一个字符。若读到文件尾而无数据时便返回EOF。虽然getc()与fgetc()作用相同，但getc()为宏定义，非真正的函数调用。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>getc()会返回读取到的字符，若返回EOF则表示到了文件尾。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>参考fgetc()。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc164></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>getchar（由标准输入设备内读进一字符） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fopen，fread，fscanf，getc<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int getchar(void);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>getchar()用来从标准输入设备中读取一个字符。然后将该字符从unsigned 
      char转换成int后返回。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 
  size=2>getchar()会返回读取到的字符，若返回EOF则表示有错误发生。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>附加说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>getchar()非真正函数，而是getc(stdin)宏定义。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR>main()<BR>{<BR>FILE * 
      fp;<BR>int 
      c,i;<BR>for(i=0li&lt;5;i++)<BR>{<BR>c=getchar();<BR>putchar(c);<BR>}<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>执行 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>1234 /*输入*/<BR>1234 /*输出*/<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc165></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>gets（由标准输入设备内读进一字符串） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fopen，fread，fscanf，fgets<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>char * gets(char *s);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>gets()用来从标准设备读入字符并存到参数s所指的内存空间，直到出现换行字符或读到文件尾为止，最后加上NULL作为字符串结束。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>gets()若成功则返回s指针，返回NULL则表示有错误发生。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>附加说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>由于gets()无法知道字符串s的大小，必须遇到换行字符或文件尾才会结束输入，因此容易造成缓冲溢出的安全性问题。建议使用fgets()取代。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>参考fgets()<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc166></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>mktemp（产生唯一的临时文件名） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>tmpfile<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdlib.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>char * mktemp(char * template);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>mktemp()用来产生唯一的临时文件名。参数template所指的文件名称字符串中最后六个字符必须是XXXXXX。产生后的文件名会借字符串指针返回。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno中。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>附加说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>参数template所指的文件名称字符串必须声明为数组，如:<BR>char template[ 
      ]=”template-XXXXXX”；<BR>不可用char * 
  template=”template-XXXXXX”；<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdlib.h&gt;<BR>main()<BR>{<BR>char 
      template[ 
      ]=”template-XXXXXX”;<BR>mktemp(template);<BR>printf(“template=%s\n”,template);<BR>}<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc167></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>putc（将一指定字符写入文件中） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fopen，fwrite，fscanf，fputc<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int putc(int c,FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>putc()会将参数c转为unsigned 
      char后写入参数stream指定的文件中。虽然putc()与fputc()作用相同，但putc()为宏定义，非真正的函数调用。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 
  size=2>putc()会返回写入成功的字符，即参数c。若返回EOF则代表写入失败。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>参考fputc（）。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc168></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>putchar（将指定的字符写到标准输出设备） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fopen，fwrite，fscanf，fputc<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int putchar (int c);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>putchar()用来将参数c字符写到标准输出设备。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 
    size=2>putchar()会返回输出成功的字符，即参数c。若返回EOF则代表输出失败。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>附加说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
  size=2>putchar()非真正函数，而是putc(c，stdout)宏定义。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>参考getchar()。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc169></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>rewind（重设文件流的读写位置为文件开头） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fseek，ftell，fgetpos，fsetpos<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>void rewind(FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>rewind()用来把文件流的读写位置移至文件开头。参数stream为已打开的文件指针。此函数相当于调用fseek(stream,0,SEEK_SET)。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>范例 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>参考fseek()<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc170></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>setbuf（设置文件流的缓冲区） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>setbuffer，setlinebuf，setvbuf<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>void setbuf(FILE * stream,char * 
    buf);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>在打开文件流后，读取内容之前，调用setbuf()可以用来设置文件流的缓冲区。参数stream为指定的文件流，参数buf指向自定的缓冲区起始地址。如果参数buf为NULL指针，则为无缓冲IO。Setbuf()相当于调用:setvbuf(stream,buf,buf?_IOFBF:_IONBF,BUFSIZ) 
      <BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc171></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>setbuffer（设置文件流的缓冲区） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>setlinebuf，setbuf，setvbuf<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>void setbuffer(FILE * stream,char * buf,size_t 
      size);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>在打开文件流后，读取内容之前，调用setbuffer()可用来设置文件流的缓冲区。参数stream为指定的文件流，参数buf指向自定的缓冲区起始地址，参数size为缓冲区大小。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc172></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>setlinebuf（设置文件流为线性缓冲区） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>setbuffer，setbuf，setvbuf<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>void setlinebuf(FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>setlinebuf()用来设置文件流以换行为依据的无缓冲IO。相当于调用:setvbuf(stream,(char * 
      )NULL,_IOLBF,0);请参考setvbuf()。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc173></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>setvbuf（设置文件流的缓冲区） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>setbuffer，setlinebuf，setbuf<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int setvbuf(FILE * stream,char * buf,int 
      mode,size_t size);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>在打开文件流后，读取内容之前，调用setvbuf()可以用来设置文件流的缓冲区。参数stream为指定的文件流，参数buf指向自定的缓冲区起始地址，参数size为缓冲区大小，参数mode有下列几种<BR>_IONBF 
      无缓冲IO<BR>_IOLBF 以换行为依据的无缓冲IO<BR>_IOFBF 
      完全无缓冲IO。如果参数buf为NULL指针，则为无缓冲IO。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR><FONT face=宋体 size=2><A 
      name=linuxc174></A></FONT></DIV></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2><BR></FONT></DIV></TD>
    <TD><FONT face=宋体 size=2><BR>ungetc（将指定字符写回文件流中） </FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>相关函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>fputc，getchar，getc<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>表头文件 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>#include&lt;stdio.h&gt;<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>定义函数 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>int ungetc(int c,FILE * stream);<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>函数说明 </FONT></DIV></TD>
    <TD><FONT face=宋体 
      size=2>ungetc()将参数c字符写回参数stream所指定的文件流。这个写回的字符会由下一个读取文件流的函数取得。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>
      <DIV align=right><FONT face=宋体 size=2>返回值 </FONT></DIV></TD>
    <TD><FONT face=宋体 size=2>成功则返回c 字符，若有错误则返回EOF。<BR></FONT></TD></TR>
  <TR>
    <TD vAlign=top width=80>　 
      <DIV align=right><BR></DIV></TD></TR></TBODY></TABLE></BODY></HTML>
